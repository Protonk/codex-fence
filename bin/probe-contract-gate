#!/usr/bin/env bash
set -euo pipefail

# Probe contract gate: runs the static probe contract and a dynamic emit-record validation.

script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)
repo_root=$(cd "${script_dir}/.." >/dev/null 2>&1 && pwd)

static_gate="${repo_root}/tools/contract_gate/static_gate.sh"
stub_template="${repo_root}/tools/contract_gate/emit_stub.sh"
portable_path="${repo_root}/bin/portable-path"
utils_path="${repo_root}/tests/library/utils.sh"

contract_run_mode="contract_check"
timeout_seconds=5

if [[ ! -x "${portable_path}" ]]; then
  echo "probe-contract-gate: missing portable-path helper at ${portable_path}" >&2
  exit 1
fi

if [[ ! -x "${static_gate}" ]]; then
  echo "probe-contract-gate: static gate not found at ${static_gate}" >&2
  exit 1
fi

if [[ ! -f "${stub_template}" ]]; then
  echo "probe-contract-gate: emit-record stub template missing at ${stub_template}" >&2
  exit 1
fi

export REPO_ROOT="${repo_root}"
if [[ -f "${utils_path}" ]]; then
  # shellcheck disable=SC1090
  source "${utils_path}"
fi

if ! declare -F resolve_probe_script_path >/dev/null 2>&1; then
  echo "probe-contract-gate: resolve_probe_script_path helper is unavailable" >&2
  exit 1
fi

if ! declare -F extract_probe_var >/dev/null 2>&1; then
  echo "probe-contract-gate: extract_probe_var helper is unavailable" >&2
  exit 1
fi

usage() {
  cat <<'USAGE' >&2
Usage: bin/probe-contract-gate <probe-id|probes/path/to/probe.sh>

Runs the static probe contract gate followed by the dynamic emit-record gate
for the specified probe.
USAGE
}

cleanup_paths=()
cleanup() {
  local target
  for target in "${cleanup_paths[@]}"; do
    if [[ -e "${target}" ]]; then
      rm -rf "${target}"
    fi
  done
}
trap cleanup EXIT

register_cleanup_path() {
  cleanup_paths+=("$1")
}

get_probe_var() {
  local script="$1"
  local var_name="$2"
  local value
  if value=$(extract_probe_var "${script}" "${var_name}" 2>/dev/null); then
    printf '%s' "${value}"
    return 0
  fi
  return 1
}

resolve_probe() {
  local identifier="$1"
  local resolved
  resolved=$(resolve_probe_script_path "${repo_root}" "${identifier}" || true)
  if [[ -z "${resolved}" ]]; then
    echo "probe-contract-gate: unable to resolve probe '${identifier}'" >&2
    exit 1
  fi
  printf '%s' "${resolved}"
}

run_with_timeout() {
  local seconds="$1"
  shift
  if command -v gtimeout >/dev/null 2>&1; then
    gtimeout "${seconds}" "$@"
    return $?
  fi
  if command -v timeout >/dev/null 2>&1; then
    timeout "${seconds}" "$@"
    return $?
  fi
  local pid
  "$@" &
  pid=$!
  local elapsed=0
  while kill -0 "${pid}" >/dev/null 2>&1; do
    if (( elapsed >= seconds )); then
      kill "${pid}" >/dev/null 2>&1 || true
      wait "${pid}" 2>/dev/null || true
      return 124
    fi
    sleep 1
    elapsed=$((elapsed + 1))
  done
  wait "${pid}"
}

collect_stub_errors() {
  local state_dir="$1"
  local error_file="${state_dir}/emit_record_errors.log"
  if [[ -s "${error_file}" ]]; then
    cat "${error_file}"
  fi
}

run_dynamic_gate() {
  local probe_path="$1"
  local probe_id="$2"
  local expected_probe_name="$3"
  local expected_primary_capability_id="$4"

  local shadow_root
  shadow_root=$(mktemp -d "${TMPDIR:-/tmp}/probe-contract-shadow.XXXXXX")
  register_cleanup_path "${shadow_root}"

  mkdir -p "${shadow_root}/bin" "${shadow_root}/probes" "${shadow_root}/tmp"

  local probe_filename
  probe_filename=$(basename "${probe_path}")
  local shadow_probe="${shadow_root}/probes/${probe_filename}"
  cp "${probe_path}" "${shadow_probe}"
  chmod +x "${shadow_probe}"

  local helper
  for helper in "${repo_root}"/bin/*; do
    local helper_name
    helper_name=$(basename "${helper}")
    if [[ "${helper_name}" == "emit-record" ]]; then
      continue
    fi
    if [[ -d "${helper}" ]]; then
      continue
    fi
    ln -s "${helper}" "${shadow_root}/bin/${helper_name}"
  done

  cp "${stub_template}" "${shadow_root}/bin/emit-record"
  chmod +x "${shadow_root}/bin/emit-record"

  local stub_state="${shadow_root}/.pcg_state"
  mkdir -p "${stub_state}"

  local probe_stdout
  probe_stdout=$(mktemp "${TMPDIR:-/tmp}/probe-contract-stdout.XXXXXX")
  register_cleanup_path "${probe_stdout}"
  local probe_stderr
  probe_stderr=$(mktemp "${TMPDIR:-/tmp}/probe-contract-stderr.XXXXXX")
  register_cleanup_path "${probe_stderr}"

  local path_prefix="${shadow_root}/bin:${PATH}"

  local run_env=(env
    PATH="${path_prefix}"
    HOME="${shadow_root}"
    TMPDIR="${shadow_root}/tmp"
    FENCE_RUN_MODE="${contract_run_mode}"
    FENCE_WORKSPACE_ROOT="${shadow_root}"
    PROBE_CONTRACT_GATE_STATE_DIR="${stub_state}"
    PROBE_CONTRACT_EXPECTED_RUN_MODE="${contract_run_mode}")

  if [[ -n "${expected_probe_name}" ]]; then
    run_env+=("PROBE_CONTRACT_EXPECTED_PROBE_NAME=${expected_probe_name}")
  fi
  if [[ -n "${expected_primary_capability_id}" ]]; then
    run_env+=("PROBE_CONTRACT_EXPECTED_PRIMARY_CAPABILITY_ID=${expected_primary_capability_id}")
  fi

  run_env+=("${shadow_probe}")

  if ! run_with_timeout "${timeout_seconds}" "${run_env[@]}" >"${probe_stdout}" 2>"${probe_stderr}"; then
    local exit_code=$?
    local stub_errors
    stub_errors=$(collect_stub_errors "${stub_state}" || true)
    if [[ -n "${stub_errors}" ]]; then
      echo "probe-contract-gate: dynamic gate failed for ${probe_id}: ${stub_errors}" >&2
    elif [[ ${exit_code} -eq 124 ]]; then
      echo "probe-contract-gate: dynamic gate timed out after ${timeout_seconds}s for ${probe_id}" >&2
    else
      echo "probe-contract-gate: dynamic gate failed for ${probe_id} (exit ${exit_code})" >&2
    fi
    if [[ -s "${probe_stderr}" ]]; then
      echo "probe stderr:" >&2
      tail -n 20 "${probe_stderr}" >&2
    fi
    return 1
  fi

  local invocation_file="${stub_state}/emit_record_invocations"
  if [[ ! -f "${invocation_file}" ]]; then
    echo "probe-contract-gate: dynamic gate failed for ${probe_id}: emit-record not invoked" >&2
    return 1
  fi
  local invocation_count
  invocation_count=$(cat "${invocation_file}" 2>/dev/null || printf '0')
  if ! [[ "${invocation_count}" =~ ^[0-9]+$ ]]; then
    echo "probe-contract-gate: dynamic gate failed for ${probe_id}: invalid invocation counter" >&2
    return 1
  fi
  if [[ "${invocation_count}" -eq 0 ]]; then
    echo "probe-contract-gate: dynamic gate failed for ${probe_id}: emit-record not called" >&2
    return 1
  fi
  if [[ "${invocation_count}" -ne 1 ]]; then
    echo "probe-contract-gate: dynamic gate failed for ${probe_id}: emit-record called ${invocation_count} times" >&2
    return 1
  fi

  local stub_errors_file="${stub_state}/emit_record_errors.log"
  if [[ -s "${stub_errors_file}" ]]; then
    echo "probe-contract-gate: dynamic gate failed for ${probe_id}: $(tr '\n' ' ' <"${stub_errors_file}")" >&2
    return 1
  fi

  local stub_status_file="${stub_state}/emit_record_status"
  if [[ ! -f "${stub_status_file}" ]]; then
    echo "probe-contract-gate: dynamic gate failed for ${probe_id}: stub status missing" >&2
    return 1
  fi
  if ! grep -q "^ok$" "${stub_status_file}" >/dev/null 2>&1; then
    echo "probe-contract-gate: dynamic gate failed for ${probe_id}: stub status not ok" >&2
    return 1
  fi

  echo "probe-contract-gate: dynamic gate passed for ${probe_id}"
}

main() {
  if [[ $# -ne 1 ]]; then
    usage
    exit 1
  fi

  local probe_identifier="$1"
  local probe_path
  probe_path=$(resolve_probe "${probe_identifier}")
  local probe_file
  probe_file=$(basename "${probe_path}")
  local probe_id=${probe_file%.sh}

  echo "probe-contract-gate: running static gate for ${probe_id}" >&2
  if ! "${static_gate}" --probe "${probe_path}"; then
    echo "probe-contract-gate: static gate failed for ${probe_id}" >&2
    exit 1
  fi

  local expected_probe_name
  expected_probe_name=$(get_probe_var "${probe_path}" "probe_name" || true)
  local expected_primary_capability_id
  expected_primary_capability_id=$(get_probe_var "${probe_path}" "primary_capability_id" || true)

  echo "probe-contract-gate: static gate passed for ${probe_id}" >&2
  echo "probe-contract-gate: running dynamic gate for ${probe_id}" >&2
  if ! run_dynamic_gate "${probe_path}" "${probe_id}" "${expected_probe_name}" "${expected_primary_capability_id}"; then
    echo "probe-contract-gate: dynamic gate failed for ${probe_id}" >&2
    exit 1
  fi

  echo "probe-contract-gate: all gates passed for ${probe_id}" >&2
}

main "$@"